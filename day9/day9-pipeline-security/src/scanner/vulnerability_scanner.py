"""
Vulnerability Scanner using Grype and Trivy
"""
import asyncio
import json
import subprocess
import tempfile
import os
from typing import Dict, List, Any
from cyclonedx.model import bom
from cyclonedx.output.json import JsonV1Dot4
from packageurl import PackageURL

class VulnerabilityScanner:
    def __init__(self):
        self.scan_cache = {}
        
    async def scan_image(self, image_name: str) -> Dict[str, Any]:
        """Scan container image for vulnerabilities using Grype"""
        print(f"ğŸ” Scanning image: {image_name}")
        
        # Simulate Grype scan results
        vulnerabilities = {
            "critical": 0,
            "high": 2,
            "medium": 5,
            "low": 12,
            "vulnerabilities": [
                {
                    "id": "CVE-2023-1234",
                    "severity": "HIGH",
                    "package": "openssl",
                    "version": "1.1.1f",
                    "description": "Buffer overflow in OpenSSL"
                },
                {
                    "id": "CVE-2023-5678",
                    "severity": "HIGH", 
                    "package": "curl",
                    "version": "7.68.0",
                    "description": "Remote code execution vulnerability"
                }
            ]
        }
        
        # Cache results
        self.scan_cache[image_name] = vulnerabilities
        return vulnerabilities
    
    async def scan_dependencies(self, requirements_file: str) -> Dict[str, Any]:
        """Scan Python dependencies for vulnerabilities"""
        print(f"ğŸ” Scanning dependencies from: {requirements_file}")
        
        try:
            # Use safety to scan for known vulnerabilities
            result = subprocess.run(
                ["safety", "check", "--json", "-r", requirements_file],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                return {"vulnerabilities": [], "safe": True}
            else:
                # Parse safety output
                vulnerabilities = json.loads(result.stdout) if result.stdout else []
                return {
                    "vulnerabilities": vulnerabilities,
                    "safe": False,
                    "count": len(vulnerabilities)
                }
        except Exception as e:
            print(f"Error scanning dependencies: {e}")
            return {"error": str(e), "safe": False}
    
    async def generate_sbom(self, project_path: str) -> Dict[str, Any]:
        """Generate Software Bill of Materials"""
        print(f"ğŸ“„ Generating SBOM for: {project_path}")
        
        components = []
        
        # Read requirements.txt
        req_file = os.path.join(project_path, "requirements.txt")
        if os.path.exists(req_file):
            with open(req_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        if '==' in line:
                            name, version = line.split('==')
                            components.append({
                                "name": name,
                                "version": version,
                                "type": "pypi",
                                "purl": f"pkg:pypi/{name}@{version}"
                            })
        
        # Save SBOM as JSON
        sbom_data = {
            "bomFormat": "CycloneDX",
            "specVersion": "1.4",
            "serialNumber": "urn:uuid:12345678-1234-1234-1234-123456789012",
            "version": 1,
            "metadata": {
                "timestamp": "2025-01-15T10:30:00Z",
                "tools": [{"name": "Custom SBOM Generator", "version": "1.0.0"}]
            },
            "components": components
        }
        
        with open("sbom.json", "w") as f:
            json.dump(sbom_data, f, indent=2)
        
        return {"components": components, "file": "sbom.json"}
    
    async def scan_secrets(self, directory: str) -> Dict[str, Any]:
        """Scan for exposed secrets"""
        print(f"ğŸ” Scanning for secrets in: {directory}")
        
        # Simulate secret scanning
        secrets_found = []
        
        # Common secret patterns
        secret_patterns = [
            "password",
            "api_key", 
            "secret_key",
            "token",
            "private_key"
        ]
        
        return {
            "secrets_found": len(secrets_found),
            "files_scanned": 25,
            "patterns_checked": len(secret_patterns)
        }
