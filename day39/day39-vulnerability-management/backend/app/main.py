from fastapi import FastAPI, BackgroundTasks, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict
import uvicorn
from datetime import datetime, timedelta
import json
import asyncio
from pathlib import Path

app = FastAPI(title="Vulnerability Management System")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# In-memory storage
vulnerabilities_db = []
scan_history = []
scan_queue = []

class ScanRequest(BaseModel):
    scan_type: str  # sast, container, dast, infrastructure
    target: str
    priority: str = "medium"

class Vulnerability(BaseModel):
    id: str
    title: str
    severity: str
    cvss_score: float
    cve_id: Optional[str]
    description: str
    affected_component: str
    remediation: str
    status: str
    detected_at: str
    scan_type: str

class ScanJob(BaseModel):
    job_id: str
    scan_type: str
    target: str
    status: str
    started_at: str
    completed_at: Optional[str]
    findings_count: int

@app.get("/")
async def root():
    return {"message": "Vulnerability Management System API", "version": "1.0.0"}

@app.post("/api/scans/trigger")
async def trigger_scan(scan_request: ScanRequest, background_tasks: BackgroundTasks):
    job_id = f"scan-{len(scan_history)+1}-{int(datetime.now().timestamp())}"
    
    job = {
        "job_id": job_id,
        "scan_type": scan_request.scan_type,
        "target": scan_request.target,
        "status": "queued",
        "started_at": datetime.now().isoformat(),
        "completed_at": None,
        "findings_count": 0
    }
    
    scan_history.append(job)
    background_tasks.add_task(execute_scan, job_id, scan_request)
    
    return {"job_id": job_id, "status": "queued"}

async def execute_scan(job_id: str, scan_request: ScanRequest):
    await asyncio.sleep(2)  # Simulate scan time
    
    job = next((j for j in scan_history if j["job_id"] == job_id), None)
    if not job:
        return
    
    job["status"] = "running"
    
    # Generate realistic vulnerabilities based on scan type
    findings = generate_scan_findings(scan_request.scan_type, scan_request.target)
    
    for finding in findings:
        vulnerabilities_db.append(finding)
    
    job["status"] = "completed"
    job["completed_at"] = datetime.now().isoformat()
    job["findings_count"] = len(findings)

def generate_scan_findings(scan_type: str, target: str) -> List[Dict]:
    findings = []
    timestamp = datetime.now().isoformat()
    
    if scan_type == "sast":
        findings = [
            {
                "id": f"SAST-{len(vulnerabilities_db)+1}",
                "title": "SQL Injection Vulnerability",
                "severity": "critical",
                "cvss_score": 9.8,
                "cve_id": None,
                "description": "SQL query constructed using string concatenation with user input",
                "affected_component": f"{target}:app/database.py:line 45",
                "remediation": "Use parameterized queries or ORM to prevent SQL injection",
                "status": "open",
                "detected_at": timestamp,
                "scan_type": "sast"
            },
            {
                "id": f"SAST-{len(vulnerabilities_db)+2}",
                "title": "Hardcoded Credentials",
                "severity": "high",
                "cvss_score": 7.5,
                "cve_id": None,
                "description": "Database password hardcoded in source code",
                "affected_component": f"{target}:app/config.py:line 12",
                "remediation": "Move credentials to environment variables or secrets management",
                "status": "open",
                "detected_at": timestamp,
                "scan_type": "sast"
            },
            {
                "id": f"SAST-{len(vulnerabilities_db)+3}",
                "title": "Insecure Deserialization",
                "severity": "high",
                "cvss_score": 8.1,
                "cve_id": None,
                "description": "pickle.loads() used on untrusted data",
                "affected_component": f"{target}:app/utils.py:line 78",
                "remediation": "Use JSON for serialization or validate input before deserialization",
                "status": "open",
                "detected_at": timestamp,
                "scan_type": "sast"
            }
        ]
    
    elif scan_type == "container":
        findings = [
            {
                "id": f"CNT-{len(vulnerabilities_db)+1}",
                "title": "Critical OpenSSL Vulnerability",
                "severity": "critical",
                "cvss_score": 9.8,
                "cve_id": "CVE-2024-8888",
                "description": "OpenSSL version 1.1.1k contains critical remote code execution vulnerability",
                "affected_component": f"{target}:openssl:1.1.1k",
                "remediation": "Update to OpenSSL 3.0.13 or later",
                "status": "open",
                "detected_at": timestamp,
                "scan_type": "container"
            },
            {
                "id": f"CNT-{len(vulnerabilities_db)+2}",
                "title": "Outdated Python Base Image",
                "severity": "medium",
                "cvss_score": 5.3,
                "cve_id": "CVE-2024-7654",
                "description": "Python 3.9.2 contains known vulnerabilities in urllib3",
                "affected_component": f"{target}:python:3.9.2",
                "remediation": "Update base image to python:3.11-slim",
                "status": "open",
                "detected_at": timestamp,
                "scan_type": "container"
            }
        ]
    
    elif scan_type == "dast":
        findings = [
            {
                "id": f"DAST-{len(vulnerabilities_db)+1}",
                "title": "Missing Security Headers",
                "severity": "medium",
                "cvss_score": 5.3,
                "cve_id": None,
                "description": "Missing X-Frame-Options, X-Content-Type-Options headers",
                "affected_component": f"{target}",
                "remediation": "Configure security headers in web server or application middleware",
                "status": "open",
                "detected_at": timestamp,
                "scan_type": "dast"
            },
            {
                "id": f"DAST-{len(vulnerabilities_db)+2}",
                "title": "Weak TLS Configuration",
                "severity": "high",
                "cvss_score": 7.5,
                "cve_id": None,
                "description": "Server accepts TLS 1.0 and weak cipher suites",
                "affected_component": f"{target}",
                "remediation": "Configure server to use TLS 1.2+ with strong cipher suites only",
                "status": "open",
                "detected_at": timestamp,
                "scan_type": "dast"
            }
        ]
    
    elif scan_type == "infrastructure":
        findings = [
            {
                "id": f"INFRA-{len(vulnerabilities_db)+1}",
                "title": "Kubernetes Pod Running as Root",
                "severity": "high",
                "cvss_score": 7.2,
                "cve_id": None,
                "description": "Container running with root privileges increases attack surface",
                "affected_component": f"{target}:deployment.yaml:securityContext",
                "remediation": "Add runAsNonRoot: true and runAsUser to pod security context",
                "status": "open",
                "detected_at": timestamp,
                "scan_type": "infrastructure"
            },
            {
                "id": f"INFRA-{len(vulnerabilities_db)+2}",
                "title": "Missing Resource Limits",
                "severity": "medium",
                "cvss_score": 4.3,
                "cve_id": None,
                "description": "Pod does not define CPU and memory limits",
                "affected_component": f"{target}:deployment.yaml:resources",
                "remediation": "Define resource requests and limits to prevent resource exhaustion",
                "status": "open",
                "detected_at": timestamp,
                "scan_type": "infrastructure"
            }
        ]
    
    return findings

@app.get("/api/vulnerabilities")
async def get_vulnerabilities(
    severity: Optional[str] = None,
    status: Optional[str] = None,
    scan_type: Optional[str] = None
):
    filtered = vulnerabilities_db
    
    if severity:
        filtered = [v for v in filtered if v["severity"] == severity]
    if status:
        filtered = [v for v in filtered if v["status"] == status]
    if scan_type:
        filtered = [v for v in filtered if v["scan_type"] == scan_type]
    
    return {"vulnerabilities": filtered, "total": len(filtered)}

@app.get("/api/vulnerabilities/{vuln_id}")
async def get_vulnerability(vuln_id: str):
    vuln = next((v for v in vulnerabilities_db if v["id"] == vuln_id), None)
    if not vuln:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    return vuln

@app.patch("/api/vulnerabilities/{vuln_id}")
async def update_vulnerability(vuln_id: str, status: str):
    vuln = next((v for v in vulnerabilities_db if v["id"] == vuln_id), None)
    if not vuln:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    
    vuln["status"] = status
    return vuln

@app.get("/api/scans/history")
async def get_scan_history():
    return {"scans": scan_history, "total": len(scan_history)}

@app.get("/api/scans/{job_id}")
async def get_scan_status(job_id: str):
    job = next((j for j in scan_history if j["job_id"] == job_id), None)
    if not job:
        raise HTTPException(status_code=404, detail="Scan job not found")
    return job

@app.get("/api/dashboard/stats")
async def get_dashboard_stats():
    total_vulns = len(vulnerabilities_db)
    critical = len([v for v in vulnerabilities_db if v["severity"] == "critical"])
    high = len([v for v in vulnerabilities_db if v["severity"] == "high"])
    medium = len([v for v in vulnerabilities_db if v["severity"] == "medium"])
    low = len([v for v in vulnerabilities_db if v["severity"] == "low"])
    
    open_vulns = len([v for v in vulnerabilities_db if v["status"] == "open"])
    in_progress = len([v for v in vulnerabilities_db if v["status"] == "in_progress"])
    resolved = len([v for v in vulnerabilities_db if v["status"] == "resolved"])
    
    scan_types_count = {}
    for v in vulnerabilities_db:
        scan_type = v["scan_type"]
        scan_types_count[scan_type] = scan_types_count.get(scan_type, 0) + 1
    
    return {
        "total_vulnerabilities": total_vulns,
        "by_severity": {
            "critical": critical,
            "high": high,
            "medium": medium,
            "low": low
        },
        "by_status": {
            "open": open_vulns,
            "in_progress": in_progress,
            "resolved": resolved
        },
        "by_scan_type": scan_types_count,
        "total_scans": len(scan_history),
        "compliance_score": calculate_compliance_score()
    }

def calculate_compliance_score() -> float:
    if not vulnerabilities_db:
        return 100.0
    
    total = len(vulnerabilities_db)
    resolved = len([v for v in vulnerabilities_db if v["status"] == "resolved"])
    critical_open = len([v for v in vulnerabilities_db 
                        if v["severity"] == "critical" and v["status"] == "open"])
    
    # Penalize heavily for open critical vulnerabilities
    score = (resolved / total * 100) - (critical_open * 10)
    return max(0.0, min(100.0, score))

@app.get("/api/reports/compliance")
async def get_compliance_report():
    report = {
        "generated_at": datetime.now().isoformat(),
        "frameworks": {
            "PCI-DSS": {
                "requirements_met": 8,
                "total_requirements": 12,
                "compliance_percentage": 66.7,
                "open_findings": [
                    "Requirement 6.5.1: SQL Injection vulnerabilities detected",
                    "Requirement 8.2.1: Hardcoded credentials found"
                ]
            },
            "SOC2": {
                "requirements_met": 15,
                "total_requirements": 18,
                "compliance_percentage": 83.3,
                "open_findings": [
                    "CC6.1: Missing security headers",
                    "CC7.2: Weak TLS configuration"
                ]
            },
            "CIS": {
                "requirements_met": 22,
                "total_requirements": 25,
                "compliance_percentage": 88.0,
                "open_findings": [
                    "CIS 5.2.1: Pods running as root",
                    "CIS 5.2.6: Missing resource limits"
                ]
            }
        },
        "overall_compliance": 79.3
    }
    return report

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
